375 0 0 - ここから 13 章
375 3 4 櫻井陸渡
"「皮肉なことに、JavaScript には非同期な処理を行うために強力な機能が備わっていますが、
JavaScript プログラム自身を非同期にするような機能はコア言語には含まれていません。このた
め、Promise や async、await、for/await を説明するために、まずクライアントサイド JavaScript
とサーバサイド JavaScript に寄り道します。」

ブラウザや Node 等の実行環境がもつ機能 → タイマー、イベント、ネットワークイベント、Node のコールバックイベント
コア言語に含まれる機能 →Promise/async/await 　　　　　　　　ということ？"
375 3 2 渡邊究
"JavaScript プログラム自身を非同期にするような機能がコア言語に含まれていない、がイメージできませんでした。
Promise などを用いずに、それぞれのプログラムの式などをサーバ・クライアントで非同期に実行するような仕様は言語にはない、のような意味？"

378 2 7 田口 大悟
"なお、addEventListener()のほうが柔軟に処理ができます。複数のイベントハン
ドラを登録できるからです。

とありますが、addEventListener() の中の処理でも各種イベント名のプロパティが存在していて、
コールバック関数を登録する処理をしているのでしょうか？

そうであれば、どのようにして同一のイベントに対して複数のイベントハンドラを登録するのでしょうか？"

379 2 1 田口 大悟
"Node の fs.readFile()関数には、第 1 引数として、2 つのパラメータを持つコールバックを指
定します。

とありますが、第一引数には string 型を指定しているように見えます。
第 3 引数に 2 つのパラメータを持つコールバックを指定している、の間違いじゃないでしょうか？"

382 4 3 田口 大悟
"then()を呼び出したときに、非同期の計算処理が完了している場合でも、非同期に呼び出されます。

とありますが、この「非同期の計算処理」とは Promise を返す関数の処理の計算処理のことでしょうか？"
389 2 5 銭　雨晨
"「p は値 v で解決されます」「p は解決されますが、まだ満たされません」
この場合は、p は pending になりますか
https://qiita.com/uhyo/items/a9f6e70f43287cc0f52e#fulfilled-rejected-settled の説明を読んで、
「ポイントは、Promise というのは自身の結果を他の Promise に委譲することができるという点です。」
ここでは、p の結果が v に依存します。つまり、p の結果が v に委譲するということですか"
389 2 9, 12 中村優希
"「これが Promise が『解決された』状態の意味するところです」「p が『解決された』の意味するところは、p の結果は Promise v に何が起きるかに完全に依存する、という意味です」　という表現が分かりにくく感じました。

あくまで「返り値 v が Promise である場合」の話をしているのに、一文だけ読むと「解決された」状態すべてについての説明と捉えられかねないからです。　
「これが Promise が『解決されたが、まだ満たされていない』状態の意味～」と書いた方が分かりやすくないでしょうか？

個人的には ECMAScript そのまま読んだ方が簡明で腑に落ちました。
ECMAScript 25.6 Promise Objects(https://262.ecma-international.org/9.0/index.html#sec-promise-objects)に以下のように書かれていました。

> A promise is resolved if it is settled or if it has been “locked in” to match the state of another promise.

後半の「他の Promise の状態に“ロックされている”場合」というのが教科書該当ページで扱っている状況で、それ以外にも単に「完了した(settled)」場合も「解決された(resolved)」と言えることが明記されています。また、

> A promise is said to be settled if it is not pending, i.e. if it is either fulfilled or rejected.

「完了した(settled)」の定義は「満たされた(fullfilled)」か「失敗した(rejected)」であることも明記されていました。"
392 1 1 渡邊究 非同期処理、例えば fetch()のタイムアウトはどのように実装するのが一般的でしょうか
394 2 2 森剛史 "コールバックが正常な場合、catch()のコールバックは呼び出されないとありますが、メソッドチェーンとして見ると途中のメソッドがスキップできる方法が分かりませんでした。
Promise の実装で、見かけ上呼び出していないようにしているのでしょうか。"
395 1 1 田口 大悟
"queryDatabase() は catch でリトライしていますが、
このコードでリトライを行って、そのリトライ後もエラーが出た場合、再度リトライされ、無限にリトライが続いてしまうと思うのですが、あっていますか？
そうだとすると問題になりませんか？"
397 5 2 澤田恭也 Response.json()の json はなぜ promise で返される仕様なのか、違和感がありました。時間がかかるかもしれないから？
400 3 1 渡邊究 例 13-1 で reject()の後に response.resume();とありますが、Error を発生させた後にここに戻ってくる、で合っていますでしょうか
404 4 1 西尾公秀
"「await キーワードはプログラムをブロックせず」とありますが、await は Promise を受け取ったら Promise の非同期処理が完了するまでは次の処理に進まない（見かけ上同期のように振る舞う）と理解しています。これは「プログラムをブロックせず」という言葉と相反するように感じました。

例えば下記のような処理をした場合は、completed が表示されるまで foo は表示されませんので、await を使わない非同期処理と比べるとプログラムをブロックしているように思ったため。

ここで言っていることは Promise の非同期処理は進めるからブロックはしていないという意味でしょうか。

function wait(msec) {
return new Promise((resolve) => setTimeout(resolve, msec));
}
const wait1 = () => wait(5000);

async function hoge() {
console.log('fuga');
await wait1().then(() => console.log('completed'));
console.log('foo');
}

hoge();

// 結果
// fuga
// completed
// foo"
405 2 1 岩崎 奨吾
"async/await を使用することによるデメリットもしくは、そもそも使えないということがどういった場面で起こるかイメージがついていません。
基本的には Promise ベースでの記述を async/await を用いて書くことで、一見同期的なコードに見え可読性が上がる。ので基本的に使えばよいが、
async の宣言がある関数中で使える記述方法のため、それに頼りすぎるのは良くない。という認識でいます。
ここで書かれている「しかし、このコードが動くのは、別の async 関数の中だけ、～トップレベルのコードや～使えません。」と念押しされていることから、
非同期処理がトップレベルのコード内によく出てくるのかなと思っているのですが、そうなのでしょうか？"
